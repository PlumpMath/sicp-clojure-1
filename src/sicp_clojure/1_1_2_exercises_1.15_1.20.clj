(ns sicp-clojure.1-1-2-exercises
  (:require [clojure.test :as t]
            [clojure.math.numeric-tower :as m :refer (expt sqrt abs)]))

;;; Exercise 1.15
;; The sine of an angle (specified in radians) can be computed by making use of the
;; approximation [...] if x is sufficiently small, and the trigonometric identity [...]

(defn cube [x] (* x x x))
(defn p [x] (- (* 3 x) (* 4 (cube x))))

(defn sine [angle]
  ; (println angle " ") ; uncomment to show
  (if (not (> (m/abs angle) 0.1))
    angle
    (p (sine (/ angle 3.0)))))

;; a.  How many times is the procedure p applied when (sine 12.15) is evaluated?
;;
;; It is evaluated 5 times with 12.15, 4.05, 1.35, 0.45 and 0.15 (the last 0.05 stops).
; (sine 12.15)

;; b.  What is the order of growth in space and number of steps (as a function of a)
;; used by the process generated by the sine procedure when (sine a) is evaluated?
;;
;; The number of steps can be calculated approximately using the logarithm to the base 3 of a.
;; Therefore, space-wise, Theta = O(log a). The space required by the recursive process
;; (p is deferred) again increases only when a is tripled. Theta is then O(log a) as well.


;;; Exercise 1.16
;; Design a procedure that evolves an iterative exponentiation process that uses successive
;; squaring and uses a logarithmic number of steps, as does fast-expt.

;; This returns correct results but it is very inefficient as it generates a lot of additional
;; exponentiations. This is evident using big numbers.
(defn- fast-expt-logarithmic* [b n a]
  (cond (= n 0) a
        (even? n) (let [half-n (quot n 2)]
                    (fast-expt-logarithmic* b
                                           half-n
                                           (* a (fast-expt-logarithmic* b half-n 1))))
        :else (fast-expt-logarithmic* b (- n 1) (* a b))))

(defn fast-expt-iter* [b n]
  (if (= n 0)
    1
    (fast-expt-logarithmic* b n 1)))

;; The correct solution where Theta(n) = O(log n) is:
(defn- fast-expt-logarithmic [b n a]
  (cond (= n 0) a
        (even? n) (fast-expt-logarithmic (* b b) (quot n 2) a)
        :else (fast-expt-logarithmic b (- n 1) (* a b))))

(defn fast-expt-iter [b n]
  (if (= n 0)
    1
    (fast-expt-logarithmic b n 1)))


;;; Exercise 1.17
(defn custom-mult [a b]
  (if (= b 0) ;; missing case if (= a 0)
    0
    (+ a (custom-mult a (- b 1)))))

;; This algorithm takes a number of steps that is linear in b. Now suppose we include,
;; together with addition, operations double, which doubles an integer, and halve, which
;; divides an (even) integer by 2. Using these, design a multiplication procedure analogous
;; to fast-expt that uses a logarithmic number of steps.

(defn- double* [x]
  (* x 2))

(defn- halve [x]
  (quot x 2))

(defn fast-mult [a b]
  (cond (or (= a 0) (= b 0)) 0
        (even? b) (+ (double* (fast-mult a (halve b))))
        :else (+ a (fast-mult a (- b 1)))))


;;; Exercise 1.18
;; Using the results of exercises 1.16 and 1.17, devise a procedure that generates
;; an iterative process for multiplying two integers in terms of adding, doubling,
;; and halving and uses a logarithmic number of steps.

;; The following solution is iterative but grows linearly with the input.
(defn- fast-mult-linear [a b acc]
  (if
    (= b 0) acc
    (fast-mult-linear a (- b 1) (+ acc (double* a)))))

(defn fast-mult-iter* [a b]
  (cond (or (= a 0) (= b 0)) 0
        (even? b) (fast-mult-linear a (halve b) 0)
        :else (fast-mult-linear a (halve b) a)))

;; This returns correct results but it is very inefficient as it generates a lot of additional
;; multiplications. This is evident using big numbers.
(defn- fast-mult-logarithmic* [a b acc]
  (cond (= b 2) (+ acc (double* a))
        (even? b) (let [half-b (halve b)]
                    (fast-mult-logarithmic* a
                                            half-b
                                            (+ acc (fast-mult-logarithmic* a half-b 0))))
        :else (fast-mult-logarithmic* a (- b 1) (+ acc a))))

(defn fast-mult-iter** [a b]
  (if (or (= a 0) (= b 0))
    0
    (fast-mult-logarithmic* a b 0)))

;; Similarly to the fast-expt-iter solution, the solution where Theta(n) = O(log n) is:
(defn- fast-mult-logarithmic [a b acc]
  (cond (= b 2) (+ acc (double* a))
        (even? b) (fast-mult-logarithmic (double* a) (halve b) acc)
        :else (fast-mult-logarithmic a (- b 1) (+ acc a))))

(defn fast-mult-iter [a b]
  (if (or (= a 0) (= b 0))
    0
    (fast-mult-logarithmic a b 0)))


;;; Exercise 1.19
;; There is a clever algorithm for computing the Fibonacci numbers in a logarithmic number of steps.
;; ...
;; Now consider T to be the special case of p = 0 and q = 1 in a family of transformations Tpq, where
;; Tpq transforms the pair (a,b) according to a = bq + aq + ap and b = bp + aq.
;; Show that if we apply such a transformation Tpq twice, the effect is the same as using a single
;; transformation Tp'q' of the same form, and compute p' and q' in terms of p and q.
;;
;; Applying Tpq twice (keeping the ordering of the variables in the book):
;; a1 = b0 q + a0 q + a0 p = b0 q + a0 (q + p)
;; b1 = b0 p + a0 q
;;
;; a2 = (b0 p + a0 q) q + (b0 q + a0 q + a0 p) q + (b0 q + a0 q + a0 p) p
;; b2 = (b0 p + a0 q) p + (b0 q + a0 q + a0 p) q
;;
;; a2 = b0 pq + a0 q² + b0 q² + a0 q² + a0 pq + b0 pq + a0 pq + a0 p²
;; b2 = b0 p² + a0 p q + b0 q² + a0 q² + a0 pq
;;
;; a2 = b0 (q² + 2pq) + a0 (2q² + 2pq + p²)
;; b2 = b0 (p² + q²) + a0 (q² + 2pq)
;;
;; Therefore Tp'q' = Tpq (applied twice) using the following definitions:
;; p' = p² + q²
;; q' = q² + 2pq
;; and q' + p' = 2q² + 2pq + p²

(defn- fib-iter [a b p q counter]
  (cond (= counter 0) b
        (even? counter) (fib-iter a
                                  b
                                  (+ (* p p) (* q q))   ; compute p'
                                  (+ (* q q) (* 2 p q)) ; compute q'
                                  (quot counter 2))
        :else (fib-iter (+ (* b q) (* a q) (* a p))
                        (+ (* b p) (* a q))
                        p
                        q
                        (- counter 1))))

(defn fib [n]
  (fib-iter 1 0 0 1 n))


;;; Exercise 1.20
;; Using the substitution method (for normal order), illustrate the process generated in evaluating
;; (gcd 206 40) and indicate the remainder operations that are actually performed. How many remainder
;; operations are actually performed in the normal-order evaluation of (gcd 206 40)? In the
;; applicative-order evaluation?

; (defn gcd [a b] (if (= b 0) a (gcd b (rem a b))))
; (gcd 206 40)

;; Normal-order evaluation:
;; (n0) (if (= 40 0) 206 (gcd 40 (rem 206 40)))
;; (n1) (if (= 40 0) 206 (if (= (rem 206 40) 0) 40 (gcd (rem 206 40) (rem 40 (rem 206 40)))))
;; (n2) [...] (if (= (rem 40 (rem 206 40)) 0)
;;             (rem 206 40)
;;             (gcd (rem 40 (rem 206 40)) (rem (rem (206 40)) (rem 40 (rem 206 40)))))
;; (n3) ...
;;
;; We can define ra and rb as the number of rem operations generated by gcd and, using n to indicate
;; steps, calculate:
;; ra(n) = rb(n-1)
;; rb(n) = 1 + ra(n-1) + rb(n-1)
;;
;; gcd itself will then generate:
;; (n0) (gcd 206 40) ra0 = 0, rb0 = 1
;; (n1) (gcd 40 6)   ra1 = 1, rb1 = 2
;; (n2) (gcd 6 4)    ra2 = 2, rb2 = 4
;; (n3) (gcd 2 0)    ra3 = 4, rb3 = 7
;;
;; Additionally, we need to take into consideration the if clause: it always evaluates the predicate
;; b first and then, at the end, the consequent clause a.
;; Therefore n0, n1, n2 and n3 will always evaluate b, which comes from the recursive gcd call.
;; According to the table above,we can calculate the number of (rem a b) operations as rb0 + rb1 +
;; + rb2 + rb3 = 14
;; Finally, the then clause a when n = 3 will evaluate ra3 = 4 operations for a grand total of 18.
;;
;; Application-order evaluation:
;; (if (= 40 0) 206 (gcd 40 (rem 206 40)))
;; (gcd 40 (rem 206 40))
;; (gcd 40 6)                          ; 1 rem evaluated
;; (if (= 6 0) 40 (gcd 6 (rem 40 6)))
;; (gcd 6 (rem 40 6))
;; (gcd 6 4)                           ; 1 rem evaluated
;; (if (= 4 0) 6 (gcd 4 (rem 6 4)))
;; (gcd 4 (rem 6 4))
;; (gcd 4 2)                           ; 1 rem evaluated
;; (if (= 2 0) 4 (gcd 2 (rem 4 2)))
;; (gcd 2 (rem 4 2))
;; (gcd 2 0)                           ; 1 rem evaluated
;; (if (= 0 0) 2 (gcd 0 (rem 2 0)))
;; 2
;;
;; Total of 4 (rem a b) operations evaluated.

(t/deftest tests
  (t/is (= 1 (fast-expt-iter 2 0)))
  (t/is (= 64 (fast-expt-iter 2 6)))
  (t/is (= 512 (fast-expt-iter 2 9)))
  (t/is (= (+ (bit-shift-right Long/MAX_VALUE 1) 1) (fast-expt-iter 2 62)))
  (t/is (= 81 (fast-expt-iter 3 4)))
  (t/is (= 243 (fast-expt-iter 3 5)))
  (t/is (= 0 (fast-mult 0 5)))
  (t/is (= 0 (fast-mult 2 0)))
  (t/is (= 10 (fast-mult 2 5)))
  (t/is (= 12 (fast-mult 2 6)))
  (t/is (= 27 (fast-mult 3 9)))
  (t/is (= 30 (fast-mult 3 10)))
  (t/is (= 33 (fast-mult 3 11)))
  (t/is (= 36 (fast-mult 3 12)))
  (t/is (= 0 (fast-mult-iter 0 5)))
  (t/is (= 0 (fast-mult-iter 2 0)))
  (t/is (= 10 (fast-mult-iter 2 5)))
  (t/is (= 12 (fast-mult-iter 2 6)))
  (t/is (= 27 (fast-mult-iter 3 9)))
  (t/is (= 30 (fast-mult-iter 3 10)))
  (t/is (= 33 (fast-mult-iter 3 11)))
  (t/is (= 36 (fast-mult-iter 3 12))))
